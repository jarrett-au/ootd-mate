# OOTD Mate - Technical Specification

## Overview

OOTD (Outfit of the Day) Mate is an AI-powered web application that helps users manage their wardrobe and receive personalized outfit recommendations. Users upload their physical profile, photos, and clothing items, then receive daily outfit suggestions with AI-generated visualizations and conversational recommendations.

**Status**: Development Phase - Image generation API is mocked

---

## Technology Stack

### Frontend
- **Framework**: React + Next.js (App Router)
- **UI Library**: shadcn/ui + Tailwind CSS
- **State Management**: React Context + Server Actions
- **Language**: TypeScript
- **Deployment**: Vercel

### Backend
- **Framework**: Python + FastAPI
- **Language**: Python 3.11+
- **API Documentation**: OpenAPI/Swagger (auto-generated by FastAPI)

### Database & Storage
- **Database**:
  - Development: SQLite (zero-config, local file-based)
  - Production: PostgreSQL (Supabase/RDS)
- **ORM**: Prisma (schema management and migrations, supports both SQLite and PostgreSQL)
- **Image Storage**:
  - Development: Local filesystem storage
  - Production: AWS S3 (or compatible like Cloudflare R2)
  - Storage abstraction layer for easy switching

### Authentication
- **Method**: OAuth (Google, GitHub, Apple)
- **Provider**: Supabase Auth or Clerk
- **Privacy**: Private by default - user data accessible only to account owner

### AI/ML Integration
- **Image Generation**: Nano-Banana API (Gemini 3 Pro Image Preview)
  - Development: Mock with static placeholder images
  - Production: Real-time streaming response
- **Conversational AI**: LLM API integration (OpenAI GPT or Anthropic Claude)

### Testing
- **Frontend**: Vitest (unit/integration) + Playwright/Cypress (E2E)
- **Backend**: pytest + pytest-asyncio

---

## Core Features

### 1. User Profile Management

#### Data Collection
- **Essential**:
  - Height (cm)
  - Weight (kg)
  - Body type (optional)
- **Style Preferences**:
  - Primary style: casual, formal, minimalist, bohemian, streetwear, etc.
  - Secondary style preferences
- **Occasion Preferences**:
  - Work/office
  - Dates/romantic
  - Casual outings
  - Events/formal
  - Athletic/sporty

#### Profile API
```python
# PUT /api/profile
{
  "height_cm": int,
  "weight_kg": int,
  "style_preferences": List[str],
  "occasion_preferences": List[str],
  "body_type": Optional[str]
}
```

---

### 2. Clothing Item Management

#### Upload Flow
1. User uploads clothing image via basic form
2. AI analyzes image and auto-tags:
   - Item type (top, bottom, dress, outerwear, shoes, accessories)
   - Primary color
   - Pattern (solid, striped, floral, etc.)
   - Material (if detectable)
3. Preview screen shows:
   - Uploaded image
   - AI-generated tags
   - User can edit tags before saving
4. Save to wardrobe

#### Item Metadata
- **AI Auto-tagged**:
  - Category/type
  - Color (primary, secondary)
  - Pattern
  - Seasonal appropriateness
- **User Editable**:
  - Name/label
  - Brand
  - Favorite status
  - Custom tags
- **Tracked**:
  - Upload date
  - Wear count
  - Last worn date

#### Clothing API
```python
# POST /api/clothing
{
  "image": File,
  "name": str,
  "category": str,  # auto-detected
  "color": str,     # auto-detected
  "pattern": str,   # auto-detected
  "is_favorite": bool = false,
  "user_tags": List[str] = []
}

# GET /api/clothing
# List all user's clothing with filters

# PUT /api/clothing/{id}
# Update item metadata

# DELETE /api/clothing/{id}
# Delete item (invalidates cache)
```

---

### 3. Daily Outfit Generation

#### Feature Flow
1. User requests daily outfit
2. System checks cache for existing recommendation
3. If cached and not invalidated, return cached result
4. If not cached:
   - Select clothing combination based on:
     - User profile (style, occasion preferences)
     - Weather/location (if available)
     - Clothing item wear counts (rotate items)
     - Seasonal appropriateness
   - Generate AI prompt including:
     - Text description of selected items
     - User profile context
     - Fashion theory terminology
   - Call image generation API (streaming response)
   - Cache result with key: hash(user_id + clothing_item_ids)
5. Display:
   - Generated outfit image
   - AI explanation of why this combination works (color theory, proportions, style matching)
   - Clothing items used with links to view/edit

#### Outfit Prompt Structure
```
Generate a fashion outfit visualization featuring:
- Person: {height}cm, {weight}kg, {body_type}
- Style: {style_preferences}
- Occasion: {occasion}
- Items: {clothing_items_description}

Fashion considerations:
- Color harmony: {explain_color_theory}
- Proportions: {explain_silhouette_balance}
- Texture coordination: {explain_material_pairing}

Aspect ratio: 4:3
```

#### Outfit API
```python
# POST /api/outfits/generate
{
  "occasion": Optional[str],  # override default
  "force_regenerate": bool = False  # bypass cache
}

# Response (streaming)
{
  "outfit_id": str,
  "image_url": str,
  "items": [
    {
      "clothing_id": str,
      "name": str,
      "category": str,
      "image_url": str
    }
  ],
  "explanation": {
    "why_it_works": str,
    "color_theory": str,
    "style_notes": str
  }
}
```

---

### 4. Conversational Recommendation

#### UI Pattern
Split view design:
- **Left/Top**: Persistent outfit card showing current suggestion
- **Right/Bottom**: Chat interface for refinement

#### Supported Interactions
1. **Natural Language Requests**:
   - "I have a date tonight, suggest something romantic but not too formal"
   - "I need an outfit for a summer outdoor wedding"
2. **Iterative Refinement**:
   - "I don't like this outfit, make it more casual"
   - "Can you suggest something with more color?"
3. **Save Collections**:
   - "Save this as my 'Summer Work' collection"
   - "Create a 'Date Night' board with this outfit"
4. **Item-Specific Q&A**:
   - "What shoes go with these jeans?"
   - "Can I wear this jacket with these pants?"

#### Conversation Context
- **Persistent History**: All conversations saved to database
- **User Profile Integration**: Chat uses style preferences and past history
- **Outfit Association**: Messages linked to generated outfits for reference

#### Chat API
```python
# POST /api/chat
{
  "message": str,
  "conversation_id": Optional[str],  # continue existing
  "outfit_id": Optional[str]  # context from specific outfit
}

# Response
{
  "conversation_id": str,
  "message": str,
  "outfit_suggestion": Optional[Outfit],  # if AI generates new outfit
  "saved_collection": Optional[Collection]  # if user requests save
}

# GET /api/chat/conversations
# List all user conversations

# GET /api/chat/conversations/{id}
# Get conversation history with associated outfits
```

---

### 5. Outfit Caching System

#### Cache Strategy
- **Type**: Exact match caching
- **Cache Key**: SHA256 hash of `{user_id}:{sorted_clothing_ids}:{occasion}`
- **Duration**: Until manual regeneration
- **Storage**: Database (outfits table with cached_for_key field)

#### Cache Invalidation Triggers
1. **Manual Regenerate**: User explicitly clicks "regenerate" button
2. **New Clothing Added**: Any new item uploaded to wardrobe
3. **Item Modified**: Clothing item metadata changed (color, category, etc.)
4. **Item Deleted**: Clothing item removed from wardrobe

#### Cache Implementation
```python
class OutfitCache:
    async def get(self, cache_key: str) -> Optional[Outfit]:
        """Retrieve cached outfit if exists and valid"""

    async def set(self, cache_key: str, outfit: Outfit):
        """Store generated outfit in cache"""

    async def invalidate_user(self, user_id: str):
        """Clear all cache entries for user when wardrobe changes"""

    async def is_valid(self, cached_outfit: Outfit) -> bool:
        """Check if all clothing items still exist"""
```

---

### 6. Credit/Coin System

#### Rate Limiting
- **Model**: Credit-based system
- **Actions Costing Credits**:
  - Generate new outfit: 1 credit
  - Regenerate outfit: 1 credit
  - Chat-based outfit generation: 1 credit
  - Text-only chat responses: Free

#### Credit Management
```python
# User credits model
{
  "user_id": str,
  "credits_remaining": int,
  "last_replenished": datetime,
  "purchase_history": List[Transaction]
}

# API endpoints
GET /api/credits  # Check balance
POST /api/credits/purchase  # Buy more credits
```

---

## Data Models

### Database Strategy
Prisma ORM provides seamless switching between SQLite (development) and PostgreSQL (production) with the same schema. The `DATABASE_URL` environment variable determines which database is used.

### Database Schema (Prisma)

#### Prisma Schema Configuration
```prisma
// apps/backend/prisma/schema.prisma

// Development: SQLite
// DATABASE_URL="file:./dev.db"

// Production: PostgreSQL
// DATABASE_URL=postgresql://user:pass@host:5432/db

datasource db {
  provider = "sqlite"  // Auto-switch based on DATABASE_URL format
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}
```

#### Database Commands
```bash
# Development (SQLite)
npx prisma migrate dev --name init
npx prisma studio  # Visual database browser

# Production (PostgreSQL)
npx prisma migrate deploy
npx prisma generate

# Reset (dev only)
npx prisma migrate reset
```

```prisma
// User Profile
model User {
  id            String   @id @default(uuid())
  email         String   @unique
  oauth_provider String
  oauth_id      String

  // Profile
  height_cm     Int?
  weight_kg     Int?
  body_type     String?
  style_preferences String[]  // ["casual", "minimalist"]
  occasion_preferences String[]  // ["work", "date"]

  // Credits
  credits_remaining Int @default(10)

  // Relations
  clothing_items  ClothingItem[]
  outfits         Outfit[]
  conversations   Conversation[]
  collections     Collection[]

  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt
}

// Clothing Items
model ClothingItem {
  id            String   @id @default(uuid())
  user_id       String
  user          User     @relation(fields: [user_id], references: [id])

  // Image
  image_url     String   // S3 or local path
  image_hash    String   // For cache invalidation

  // AI Auto-tagged
  category      String   // top, bottom, dress, outerwear, shoes, accessories
  color         String
  pattern       String
  season        String?  // spring, summer, fall, winter

  // User Editable
  name          String
  brand         String?
  is_favorite   Boolean  @default(false)
  user_tags     String[]

  // Tracking
  wear_count    Int      @default(0)
  last_worn     DateTime?

  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  @@index([user_id])
  @@index([category])
}

// Generated Outfits
model Outfit {
  id            String   @id @default(uuid())
  user_id       String
  user          User     @relation(fields: [user_id], references: [id])

  // Generated content
  image_url     String
  prompt        String   // Full AI prompt used

  // AI explanation
  explanation   String   // Why this combination works
  color_theory  String
  style_notes   String

  // Cache key for exact match
  cache_key     String?  @unique

  // Occasion/context
  occasion      String?

  // Relations
  clothing_items OutfitClothingItem[]

  created_at    DateTime @default(now())

  @@index([user_id])
  @@index([cache_key])
}

// Join table for outfit clothing items
model OutfitClothingItem {
  outfit_id     String
  clothing_id   String
  outfit        Outfit        @relation(fields: [outfit_id], references: [id], onDelete: Cascade)
  clothing      ClothingItem  @relation(fields: [clothing_id], references: [id], onDelete: Cascade)

  id            String        @id @default(uuid())

  @@id([outfit_id, clothing_id])
}

// Chat Conversations
model Conversation {
  id            String   @id @default(uuid())
  user_id       String
  user          User     @relation(fields: [user_id], references: [id])

  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  messages      Message[]

  @@index([user_id])
}

model Message {
  id              String        @id @default(uuid())
  conversation_id String
  conversation    Conversation  @relation(fields: [conversation_id], references: [id], onDelete: Cascade)

  role            String        // user, assistant
  content         String

  // If this message generated an outfit
  outfit_id       String?

  created_at      DateTime      @default(now())

  @@index([conversation_id])
}

// Saved Outfit Collections
model Collection {
  id            String   @id @default(uuid())
  user_id       String
  user          User     @relation(fields: [user_id], references: [id])

  name          String
  description   String?
  outfits       Outfit[]  // Many-to-many if needed

  created_at    DateTime @default(now())

  @@index([user_id])
}
```

---

## API Endpoints

### Authentication (via Supabase/Clerk)
```
GET  /auth/login          # Initiate OAuth flow
GET  /auth/callback       # OAuth callback
POST /auth/logout         # End session
GET  /auth/me             # Get current user
```

### User Profile
```
GET    /api/profile              # Get user profile
PUT    /api/profile              # Update profile
DELETE /api/profile              # Delete account + data
```

### Clothing Management
```
GET    /api/clothing             # List all items (with filters)
POST   /api/clothing             # Upload new item
GET    /api/clothing/{id}        # Get item details
PUT    /api/clothing/{id}        # Update item
DELETE /api/clothing/{id}        # Delete item
POST   /api/clothing/{id}/wear   # Increment wear count
```

### Outfit Generation
```
POST   /api/outfits/generate     # Generate daily outfit
GET    /api/outfits              # List user's outfits
GET    /api/outfits/{id}         # Get outfit details
DELETE /api/outfits/{id}         # Delete outfit
POST   /api/outfits/{id}/regenerate  # Force regeneration
```

### Conversational AI
```
POST   /api/chat                 # Send message
GET    /api/chat/conversations   # List conversations
GET    /api/chat/conversations/{id}  # Get conversation history
DELETE /api/chat/conversations/{id}  # Delete conversation
```

### Collections
```
GET    /api/collections          # List user's collections
POST   /api/collections          # Create collection
GET    /api/collections/{id}     # Get collection
PUT    /api/collections/{id}     # Update collection
DELETE /api/collections/{id}     # Delete collection
POST   /api/collections/{id}/outfits  # Add outfit to collection
```

### Credits
```
GET    /api/credits              # Get credit balance
POST   /api/credits/purchase     # Purchase credits
GET    /api/credits/history      # Transaction history
```

---

## File Storage Strategy

### Storage Abstraction

```python
# backend/app/storage/interface.py
from abc import ABC, abstractmethod
from io import BytesIO

class StorageBackend(ABC):
    @abstractmethod
    async def upload(self, file: BytesIO, path: str) -> str:
        """Upload file and return public URL"""
        pass

    @abstractmethod
    async def delete(self, path: str) -> None:
        """Delete file by path"""
        pass

    @abstractmethod
    async def get_url(self, path: str) -> str:
        """Get public URL for file"""
        pass
```

### Local Storage (Development)

```python
# backend/app/storage/local.py
import os
from pathlib import Path

class LocalStorageBackend(StorageBackend):
    def __init__(self, base_path: str = "./uploads"):
        self.base_path = Path(base_path)
        self.base_url = os.getenv("LOCAL_STORAGE_URL", "http://localhost:8000/uploads")

    async def upload(self, file: BytesIO, path: str) -> str:
        full_path = self.base_path / path
        full_path.parent.mkdir(parents=True, exist_ok=True)

        with open(full_path, "wb") as f:
            f.write(file.getvalue())

        return f"{self.base_url}/{path}"

    async def delete(self, path: str) -> None:
        full_path = self.base_path / path
        if full_path.exists():
            full_path.unlink()

    async def get_url(self, path: str) -> str:
        return f"{self.base_url}/{path}"
```

### S3 Storage (Production)

```python
# backend/app/storage/s3.py
import boto3
from botocore.client import Config

class S3StorageBackend(StorageBackend):
    def __init__(self):
        self.s3 = boto3.client('s3')
        self.bucket = os.getenv("S3_BUCKET")
        self.region = os.getenv("S3_REGION")
        self.cloudfront_domain = os.getenv("CLOUDFRONT_DOMAIN")

    async def upload(self, file: BytesIO, path: str) -> str:
        self.s3.upload_fileobj(
            file,
            self.bucket,
            path,
            ExtraArgs={'ACL': 'public-read'}
        )

        if self.cloudfront_domain:
            return f"https://{self.cloudfront_domain}/{path}"
        return f"https://{self.bucket}.s3.{self.region}.amazonaws.com/{path}"

    async def delete(self, path: str) -> None:
        self.s3.delete_object(Bucket=self.bucket, Key=path)

    async def get_url(self, path: str) -> str:
        return self.upload(None, path)  # Reuse URL logic
```

### Configuration

```python
# backend/app/config.py
import os

STORAGE_BACKEND = os.getenv("STORAGE_BACKEND", "local")  # local | s3

def get_storage() -> StorageBackend:
    if STORAGE_BACKEND == "s3":
        return S3StorageBackend()
    return LocalStorageBackend()
```

---

## Image Generation

### Nano-Banana API Integration

#### Request Format
```python
# backend/app/services/image_generator.py
import httpx
import os

class ImageGenerator:
    def __init__(self):
        self.api_url = "https://api.302.ai/google/v1/models/gemini-3-pro-image-preview"
        self.api_key = os.getenv("NANO_BANANA_API_KEY")

    async def generate_outfit(self, prompt: str):
        """Generate outfit image with streaming response"""

        payload = {
            "contents": [{
                "parts": [{"text": prompt}]
            }],
            "generationConfig": {
                "responseModalities": ["TEXT", "IMAGE"],
                "imageConfig": {
                    "aspectRatio": "4:3"
                }
            }
        }

        async with httpx.AsyncClient() as client:
            async with client.stream(
                "POST",
                self.api_url,
                headers={
                    "Authorization": f"Bearer {self.api_key}",
                    "Content-Type": "application/json"
                },
                json=payload,
                timeout=60.0
            ) as response:
                async for chunk in response.aiter_bytes():
                    yield chunk  # Stream to client
```

#### Mock Implementation (Development)

```python
# backend/app/services/image_generator_mock.py

class MockImageGenerator(ImageGenerator):
    """Static placeholder images for development"""

    PLACEHOLDER_IMAGES = [
        "https://placehold.co/800x600/f3f4f6/1f2937?text=Outfit+1",
        "https://placehold.co/800x600/e0e7ff/3730a3?text=Outfit+2",
        "https://placehold.co/800x600/fce7f3/9d174d?text=Outfit+3",
    ]

    async def generate_outfit(self, prompt: str):
        """Return static placeholder based on prompt hash"""
        import hashlib

        # Consistent image for same prompt
        hash_val = int(hashlib.md5(prompt.encode()).hexdigest(), 16)
        image_url = self.PLACEHOLDER_IMAGES[hash_val % len(self.PLACEHOLDER_IMAGES)]

        # Mock streaming response
        mock_response = {
            "candidates": [{
                "content": {
                    "parts": [{"url": image_url}],
                    "role": "model"
                },
                "finishReason": "STOP",
                "index": 0
            }],
            "modelVersion": "mock-development",
            "responseId": "mock-" + str(hash_val)[:8]
        }

        import json
        yield (json.dumps(mock_response).encode())
```

---

## Project Structure

### Monorepo Layout

```
ootd-mate/
├── apps/
│   ├── frontend/              # Next.js application
│   │   ├── app/
│   │   │   ├── (auth)/
│   │   │   │   └── login/
│   │   │   ├── dashboard/
│   │   │   ├── wardrobe/
│   │   │   ├── outfits/
│   │   │   ├── chat/
│   │   │   └── profile/
│   │   ├── components/
│   │   │   ├── ui/            # shadcn/ui components
│   │   │   ├── wardrobe/
│   │   │   ├── outfits/
│   │   │   └── chat/
│   │   ├── lib/
│   │   │   └── api.ts         # API client
│   │   ├── public/
│   │   └── package.json
│   │
│   └── backend/               # FastAPI application
│       ├── app/
│       │   ├── api/
│       │   │   ├── endpoints/
│       │   │   │   ├── auth.py
│       │   │   │   ├── clothing.py
│       │   │   │   ├── outfits.py
│       │   │   │   ├── chat.py
│       │   │   │   └── profiles.py
│       │   │   └── deps.py    # Dependencies
│       │   ├── core/
│       │   │   └── config.py
│       │   ├── models/
│       │   │   └── database.py # SQLAlchemy models
│       │   ├── services/
│       │   │   ├── image_generator.py
│       │   │   ├── image_generator_mock.py
│       │   │   ├── outfit_service.py
│       │   │   ├── chat_service.py
│       │   │   └── cache_service.py
│       │   ├── storage/
│       │   │   ├── interface.py
│       │   │   ├── local.py
│       │   │   └── s3.py
│       │   └── main.py
│       ├── prisma/
│       │   └── schema.prisma
│       ├── tests/
│       │   ├── test_api/
│       │   ├── test_services/
│       │   └── conftest.py
│       ├── uploads/            # Local storage (dev only)
│       ├── dev.db              # SQLite database (dev only, created automatically)
│       ├── requirements.txt
│       └── pyproject.toml
│
├── packages/
│   └── shared/                # Shared types, utilities
│       ├── types/
│       └── utils/
│
├── docs/
│   ├── SPEC.md
│   └── API.md
│
├── .env.example
├── .gitignore                 # Includes dev.db, uploads/, node_modules/, .env
├── docker-compose.yml         # Optional: Local development with PostgreSQL
├── package.json               # Root package.json
└── turbo.json                 # Turborepo config
```

---

## Environment Configuration

### Root (.env.example)
```bash
# Copy this file to .env and configure for your environment

# ===========================================
# DATABASE - Choose one based on environment
# ===========================================
# Development: SQLite (zero-config, file-based)
DATABASE_URL=file:./apps/backend/dev.db

# Production: PostgreSQL (Supabase/RDS)
# DATABASE_URL=postgresql://user:pass@host:5432/ootd_mate

# ===========================================
# STORAGE
# ===========================================
# Development: Local filesystem
STORAGE_BACKEND=local
LOCAL_STORAGE_URL=http://localhost:8000/uploads

# Production: S3-compatible storage
# STORAGE_BACKEND=s3
# S3_BUCKET=ootd-mate-prod
# S3_REGION=us-east-1
# AWS_ACCESS_KEY_ID=your_key
# AWS_SECRET_ACCESS_KEY=your_secret
# CLOUDFRONT_DOMAIN=d111111abcdef8.cloudfront.net

# ===========================================
# AUTHENTICATION
# ===========================================
SUPABASE_URL=your_supabase_url
SUPABASE_SERVICE_KEY=your_supabase_service_key

# ===========================================
# AI API KEYS
# ===========================================
NANO_BANANA_API_KEY=your_nano_banana_key
OPENAI_API_KEY=your_openai_key  # For conversational AI

# ===========================================
# APP SETTINGS
# ===========================================
DEFAULT_CREDITS=10
CORS_ORIGINS=http://localhost:3000
```

### Frontend (.env.local)
```bash
NEXT_PUBLIC_API_URL=http://localhost:8000
NEXT_PUBLIC_APP_URL=http://localhost:3000
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
```

---

## Internationalization

### Supported Languages
- English (en)
- Chinese (zh)

### Implementation (Next.js i18n)

```typescript
// apps/frontend/lib/i18n.ts
export const defaultLocale = 'en'
export const locales = ['en', 'zh'] as const
export type Locale = typeof locales[number]

export const messages = {
  en: {
    wardrobe: {
      title: 'My Wardrobe',
      upload: 'Upload Item',
      items: 'items'
    },
    // ... more translations
  },
  zh: {
    wardrobe: {
      title: '我的衣橱',
      upload: '上传衣物',
      items: '件'
    },
    // ... more translations
  }
}
```

---

## Development Workflow

### Local Development

#### Option 1: SQLite (Recommended for Development)
```bash
# No database server needed - just run migrations
cd apps/backend
npx prisma migrate dev

# Start backend (uses DATABASE_URL=file:./dev.db)
uvicorn app.main:app --reload

# Start frontend
cd ../frontend
npm run dev
```

#### Option 2: Docker Compose (with PostgreSQL)
```yaml
# docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: ootd_mate
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  backend:
    build: ./apps/backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/ootd_mate
      - STORAGE_BACKEND=local
    volumes:
      - ./apps/backend:/app
    depends_on:
      - postgres

  frontend:
    build: ./apps/frontend
    ports:
      - "3000:3000"
    environment:
      - NEXT_PUBLIC_API_URL=http://localhost:8000
    volumes:
      - ./apps/frontend:/app
      - /app/node_modules
    depends_on:
      - backend

volumes:
  postgres_data:
```

```bash
# Start with PostgreSQL
docker-compose up

# Or use SQLite for simpler local dev (no Docker needed)
```

---

## Testing Strategy

### Frontend Tests

#### Unit + Integration (Vitest)
```typescript
// apps/frontend/components/__tests__/OutfitCard.test.tsx
import { render, screen } from '@testing-library/react'
import { OutfitCard } from '../OutfitCard'

describe('OutfitCard', () => {
  it('displays outfit image and explanation', () => {
    const mockOutfit = {
      id: '1',
      image_url: 'https://example.com/outfit.jpg',
      explanation: 'This works because...',
      items: []
    }
    render(<OutfitCard outfit={mockOutfit} />)

    expect(screen.getByAltText('Generated outfit')).toBeInTheDocument()
    expect(screen.getByText('This works because...')).toBeInTheDocument()
  })
})
```

#### E2E (Playwright)
```typescript
// apps/frontend/e2e/outfit-generation.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Daily Outfit Generation', () => {
  test('generates and displays outfit', async ({ page }) => {
    await page.goto('/outfits')
    await page.click('button:has-text("Generate Outfit")')

    // Wait for image to load
    const outfitImage = page.locator('img[alt*="outfit"]')
    await expect(outfitImage).toBeVisible()

    // Check explanation is shown
    await expect(page.locator('text=Why this works')).toBeVisible()
  })
})
```

### Backend Tests

#### API Tests (pytest)
```python
# apps/backend/tests/test_api/test_outfits.py
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_generate_outfit(client: AsyncClient, auth_headers):
    response = await client.post(
        "/api/outfits/generate",
        headers=auth_headers
    )

    assert response.status_code == 200
    data = response.json()
    assert "outfit_id" in data
    assert "image_url" in data
    assert "explanation" in data

@pytest.mark.asyncio
async def test_cache_outfit(client: AsyncClient, auth_headers):
    # First call
    response1 = await client.post("/api/outfits/generate", headers=auth_headers)
    outfit_id_1 = response1.json()["outfit_id"]

    # Second call should return cached
    response2 = await client.post("/api/outfits/generate", headers=auth_headers)
    outfit_id_2 = response2.json()["outfit_id"]

    assert outfit_id_1 == outfit_id_2  # Same outfit from cache
```

#### Service Tests
```python
# apps/backend/tests/test_services/test_cache.py
import pytest
from app.services.cache_service import OutfitCache

@pytest.mark.asyncio
async def test_cache_invalidates_on_new_clothing(db_session):
    cache = OutfitCache(db_session)

    # Create cache entry
    await cache.set("user1:item1,item2", mock_outfit)

    # Add new clothing (should invalidate cache)
    await clothing_service.create_item(user_id="user1", ...)

    # Cache should be empty
    cached = await cache.get("user1:item1,item2")
    assert cached is None
```

---

## Deployment

### Vercel Deployment

#### Frontend (apps/frontend)
```bash
# Auto-deploy on git push to main
# vercel.json
{
  "buildCommand": "cd ../.. && turbo build --filter=frontend",
  "outputDirectory": ".next",
  "framework": "nextjs"
}
```

#### Backend Options for Vercel
Since FastAPI doesn't deploy directly to Vercel, use one of:

1. **Railway/Render** (recommended)
   ```bash
   railway deploy
   ```

2. **AWS ECS/EKS**
   ```bash
   # Dockerfile for backend
   FROM python:3.11-slim
   WORKDIR /app
   COPY requirements.txt .
   RUN pip install --no-cache-dir -r requirements.txt
   COPY . .
   CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
   ```

3. **Vercel Serverless Functions**
   - Adapt FastAPI endpoints to Vercel Python runtime
   - Limited cold start performance

### Environment Variables (Production)
Set these in your deployment platform:

```bash
# Production URLs
NEXT_PUBLIC_API_URL=https://api.ootdmate.com
NEXT_PUBLIC_APP_URL=https://ootdmate.com

# Production database
DATABASE_URL=postgresql://user:pass@prod-db.amazonaws.com:5432/ootd_mate

# S3 Storage
STORAGE_BACKEND=s3
S3_BUCKET=ootd-mate-prod
S3_REGION=us-east-1
CLOUDFRONT_DOMAIN=d123456.cloudfront.net

# Production API keys
NANO_BANANA_API_KEY=prod_key
OPENAI_API_KEY=prod_key
```

---

## Security Considerations

1. **Image Upload Validation**
   - File type checking (allow: jpg, jpeg, png, webp)
   - File size limits (max 5MB per image)
   - Virus scanning (ClamAV) for production

2. **API Security**
   - Rate limiting per user (credit system)
   - API key rotation for external services
   - CORS configuration for production domains only

3. **Data Privacy**
   - All user images private by default
   - No training AI models on user photos without explicit consent
   - GDPR-compliant data export and deletion

4. **Authentication**
   - Secure OAuth flow with PKCE
   - HTTP-only cookies for sessions
   - CSRF protection

---

## Performance Optimization

1. **Image Optimization**
   - Generate multiple sizes (thumbnail, medium, full)
   - Use WebP format with JPEG fallback
   - Lazy loading in frontend

2. **Caching Strategy**
   - CDN for all static assets
   - Database query result caching (Redis)
   - Outfit generation caching (exact match)

3. **Database**
   - Indexed fields: user_id, cache_key, category
   - Connection pooling
   - Query optimization with Prisma

---

## Error Handling

### Image Generation Failures
```python
class ImageGenerationError(Exception):
    pass

async def generate_with_retry(prompt: str, max_retries: int = 3):
    for attempt in range(max_retries):
        try:
            return await image_generator.generate_outfit(prompt)
        except httpx.TimeoutError:
            if attempt == max_retries - 1:
                raise ImageGenerationError("Generation timed out")
            await asyncio.sleep(2 ** attempt)  # Exponential backoff
    ```

### User-Facing Error Messages
```typescript
// apps/frontend/lib/errors.ts
export class OutfitGenerationError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'OutfitGenerationError'
  }
}

// UI component
{
  error && (
    <Alert variant="destructive">
      <AlertCircle className="h-4 w-4" />
      <AlertTitle>Generation Failed</AlertTitle>
      <AlertDescription>
        {error.message}. <Button onClick={retry}>Try Again</Button>
      </AlertDescription>
    </Alert>
  )
}
```

---

## Roadmap

### Phase 1: MVP (Development)
- [x] Specification complete
- [ ] User authentication (OAuth)
- [ ] Profile management
- [ ] Clothing upload with AI tagging
- [ ] Daily outfit generation (mock)
- [ ] Basic caching system

### Phase 2: Conversational Features
- [ ] Chat UI (split view)
- [ ] LLM API integration
- [ ] Conversation history
- [ ] Save outfit collections

### Phase 3: Production Readiness
- [ ] Real image generation (Nano-Banana)
- [ ] S3 storage integration
- [ ] Credit system
- [ ] Rate limiting
- [ ] E2E testing

### Phase 4: Enhanced Features
- [ ] Weather-based recommendations
- [ ] Social sharing (optional)
- [ ] Mobile app (React Native)
- [ ] Style calendar/planner

---

## Appendix: Nano-Banana API Reference

### Image Generation Endpoint
```
POST https://api.302.ai/google/v1/models/gemini-3-pro-image-preview
Authorization: Bearer YOUR_API_KEY
Content-Type: application/json

{
  "contents": [
    {
      "parts": [
        {"text": "Your prompt here"}
      ]
    }
  ],
  "generationConfig": {
    "responseModalities": ["TEXT", "IMAGE"],
    "imageConfig": {
      "aspectRatio": "4:3"  // or "1:1", "16:9", "3:4"
    }
  }
}
```

### Response Format
```json
{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "url": "https://file.302.ai/gpt/imgs/20260103/983491b3..."
          }
        ],
        "role": "model"
      },
      "finishReason": "STOP",
      "index": 0
    }
  ],
  "modelVersion": "gemini-3-pro-image-preview",
  "responseId": "VFBZac-tFu6p_uMPycCNyAg",
  "usageMetadata": {
    "candidatesTokenCount": 1234,
    "promptTokenCount": 34,
    "totalTokenCount": 1489
  }
}
```

---

*Document Version: 1.0*
*Last Updated: 2025-01-12*
